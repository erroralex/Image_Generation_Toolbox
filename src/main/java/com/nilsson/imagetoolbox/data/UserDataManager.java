package com.nilsson.imagetoolbox.data;

import javafx.concurrent.Task;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Inject;
import java.awt.Desktop;
import java.io.File;
import java.io.FileInputStream;
import java.security.MessageDigest;
import java.util.*;

/**
 <h2>UserDataManager</h2>
 <p>
 Acts as the central Facade between the UI/ViewModels and the underlying data repositories.
 This class abstracts the complexity of data persistence, file system interactions, and
 path normalization.
 </p>
 * <h3>Key Responsibilities:</h3>
 <ul>
 <li><b>Path Normalization:</b> Manages the conversion between absolute system paths used by
 the UI and relative paths stored in the database to ensure library portability.</li>
 <li><b>Concurrency Control:</b> Relies on the underlying {@link DatabaseService} (HikariCP + SQLite WAL)
 to handle concurrent access safely, avoiding application-level locking bottlenecks.</li>
 <li><b>File Identity & Integrity:</b> Handles SHA-256 hashing for file tracking and
 delegates metadata extraction/caching.</li>
 <li><b>Domain Delegation:</b> Orchestrates operations across {@link ImageRepository},
 {@link CollectionRepository}, and {@link SettingsRepository}.</li>
 </ul>
 */
public class UserDataManager {

    private static final Logger logger = LoggerFactory.getLogger(UserDataManager.class);

    // --- Repositories & Services ---
    private final DatabaseService db;
    private final SettingsRepository settingsRepo;
    private final CollectionRepository collectionRepo;
    private final ImageRepository imageRepo;

    // --- Environment ---
    private final File libraryRoot;

    @Inject
    public UserDataManager(DatabaseService db,
                           SettingsRepository settingsRepo,
                           CollectionRepository collectionRepo,
                           ImageRepository imageRepo) {
        this.db = db;
        this.settingsRepo = settingsRepo;
        this.collectionRepo = collectionRepo;
        this.imageRepo = imageRepo;
        this.libraryRoot = new File(System.getProperty("user.dir")).getAbsoluteFile();
        logger.info("UserDataManager initialized. Library root: {}", libraryRoot);
    }

    /**
     Gracefully shuts down the underlying database services.
     */
    public void shutdown() {
        logger.info("Shutting down data services...");
        db.shutdown();
    }

    // --- Path Normalization Logic ---

    private File resolvePath(String dbPath) {
        if (dbPath == null) return null;
        File potentiallyAbsolute = new File(dbPath);
        if (potentiallyAbsolute.isAbsolute()) {
            return potentiallyAbsolute;
        }
        String systemPath = dbPath.replace("/", File.separator);
        return new File(libraryRoot, systemPath);
    }

    private String relativizePath(File file) {
        if (file == null) return null;
        try {
            java.nio.file.Path rootPath = libraryRoot.toPath();
            java.nio.file.Path filePath = file.getAbsoluteFile().toPath();
            if (filePath.startsWith(rootPath)) {
                return rootPath.relativize(filePath).toString().replace("\\", "/");
            }
        } catch (Exception e) {
            logger.warn("Failed to relativize path: {}", file, e);
        }
        return file.getAbsolutePath().replace("\\", "/");
    }

    // --- Search & Attributes ---

    public List<String> getDistinctMetadataValues(String key) {
        return imageRepo.getDistinctValues(key);
    }

    public Task<List<File>> findFilesWithFilters(String query, Map<String, String> filters, int limit) {
        return new Task<>() {
            @Override
            protected List<File> call() {
                long start = System.currentTimeMillis();
                List<String> paths = imageRepo.findPaths(query, filters, limit);
                List<File> files = new ArrayList<>();
                for (String path : paths) {
                    File f = resolvePath(path);
                    if (f != null) files.add(f);
                }
                logger.debug("Search found {} files in {}ms", files.size(), System.currentTimeMillis() - start);
                return files;
            }
        };
    }

    // --- File Operations & Identity ---

    public boolean moveFileToTrash(File file) {
        if (file == null || !file.exists()) return false;

        boolean success = false;
        if (Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.MOVE_TO_TRASH)) {
            try {
                success = Desktop.getDesktop().moveToTrash(file);
            } catch (Exception e) {
                logger.error("System trash failed", e);
                return false;
            }
        }

        if (success) {
            imageRepo.deleteByPath(relativizePath(file));
        }
        return success;
    }

    private int getOrCreateImageIdInternal(File file) {
        try {
            String path = relativizePath(file);
            String hash = calculateHash(file);
            
            // Check if file exists at path
            int id = imageRepo.getIdByPath(path);
            if (id != -1) return id;

            // Check if file was moved (same hash, different path)
            List<String> existingPaths = imageRepo.findPathsByHash(hash);
            if (!existingPaths.isEmpty()) {
                // Found a match by hash. Assume it's a move/rename.
                // Update the old path to the new path.
                String oldPath = existingPaths.get(0);
                logger.info("Detected file move: {} -> {}", oldPath, path);
                imageRepo.updatePath(oldPath, path);
                return imageRepo.getIdByPath(path);
            }

            // New file
            return imageRepo.getOrCreateId(path, hash);
        } catch (Exception e) {
            logger.error("Failed to get ID for file: {}", file, e);
            return -1;
        }
    }

    private String calculateHash(File file) {
        try (FileInputStream fis = new FileInputStream(file)) {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] buffer = new byte[8192];
            int n;
            while ((n = fis.read(buffer)) != -1) {
                digest.update(buffer, 0, n);
            }
            byte[] bytes = digest.digest();
            StringBuilder sb = new StringBuilder();
            for (byte b : bytes) sb.append(String.format("%02x", b));
            return sb.toString();
        } catch (Exception e) {
            logger.error("Hash calculation failed: {}", file, e);
            return "hash_error_" + System.currentTimeMillis();
        }
    }

    // --- Metadata & Tags ---

    public void cacheMetadata(File file, Map<String, String> meta) {
        if (file == null || meta == null || meta.isEmpty()) return;
        int id = getOrCreateImageIdInternal(file);
        if (id > 0) imageRepo.saveMetadata(id, meta);
    }

    public Map<String, String> getCachedMetadata(File file) {
        return imageRepo.getMetadata(relativizePath(file));
    }

    public boolean hasCachedMetadata(File file) {
        return imageRepo.hasMetadata(relativizePath(file));
    }

    public void addTag(File file, String tag) {
        if (file == null || tag == null || tag.isBlank()) return;
        int id = getOrCreateImageIdInternal(file);
        if (id > 0) imageRepo.addTag(id, tag.trim());
    }

    public Set<String> getTags(File file) {
        return imageRepo.getTags(relativizePath(file));
    }

    // --- Ratings & Folders ---

    public int getRating(File file) {
        return imageRepo.getRating(relativizePath(file));
    }

    public void setRating(File file, int rating) {
        if (file == null) return;
        int id = getOrCreateImageIdInternal(file);
        if (id > 0) imageRepo.setRating(id, rating);
    }

    public List<File> getStarredFilesList() {
        List<String> paths = imageRepo.getStarredPaths();
        List<File> files = new ArrayList<>();
        for (String p : paths) {
            File f = resolvePath(p);
            if (f != null && f.exists()) files.add(f);
        }
        return files;
    }

    public List<File> getPinnedFolders() {
        return imageRepo.getPinnedFolders(this::resolvePath);
    }

    public void addPinnedFolder(File folder) {
        if (folder != null && folder.isDirectory()) {
            imageRepo.addPinnedFolder(relativizePath(folder));
        }
    }

    public void removePinnedFolder(File folder) {
        if (folder != null) {
            imageRepo.removePinnedFolder(relativizePath(folder));
        }
    }

    // --- Collections ---

    public List<String> getCollections() {
        return collectionRepo.getAllNames();
    }

    public void createCollection(String name) {
        collectionRepo.create(name);
    }

    public void deleteCollection(String name) {
        collectionRepo.delete(name);
    }

    public void addImageToCollection(String collectionName, File file) {
        if (collectionName == null || file == null) return;
        int id = getOrCreateImageIdInternal(file);
        if (id > 0) {
            collectionRepo.addImage(collectionName, id);
        }
    }

    public List<File> getFilesFromCollection(String collectionName) {
        List<String> paths = collectionRepo.getFilePaths(collectionName);
        List<File> files = new ArrayList<>();
        for (String p : paths) {
            File f = resolvePath(p);
            if (f != null && f.exists()) files.add(f);
        }
        return files;
    }

    // --- Settings ---

    public String getSetting(String key, String defaultValue) {
        return settingsRepo.get(key, defaultValue);
    }

    public void setSetting(String key, String value) {
        settingsRepo.set(key, value);
    }

    public File getLastFolder() {
        String path = settingsRepo.get("last_folder", null);
        return path != null ? resolvePath(path) : null;
    }

    public void setLastFolder(File folder) {
        if (folder != null) {
            settingsRepo.set("last_folder", relativizePath(folder));
        }
    }
}