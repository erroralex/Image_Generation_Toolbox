package com.nilsson.imagetoolbox.service;

import com.drew.imaging.ImageMetadataReader;
import com.drew.metadata.Directory;
import com.drew.metadata.Metadata;
import com.drew.metadata.Tag;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nilsson.imagetoolbox.service.parser.TextParamsParser;
import com.nilsson.imagetoolbox.service.strategy.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.ImageInputStream;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.*;

/**
 <h2>MetadataService</h2>
 <p>
 This service class acts as the central engine for extracting, parsing, and interpreting
 metadata embedded within images generated by various AI tools. It handles the
 complexities of different storage locations (PNG chunks, EXIF, User Comments) and
 disparate data formats (Raw text, JSON, API Graphs).
 </p>

 <h3>Key Capabilities:</h3>
 <ul>
 <li><b>Multi-Format Support:</b> Orchestrates extraction for SwarmUI, ComfyUI,
 InvokeAI, NovelAI, and Automatic1111/Forge.</li>
 <li><b>Strategy-Based Parsing:</b> Utilizes a collection of {@link MetadataStrategy}
 implementations to recursively crawl JSON structures and extract generation parameters.</li>
 <li><b>Heuristic Scoring:</b> Implements a "best-chunk" selection algorithm to identify
 the most relevant metadata block when multiple tags are present in an image.</li>
 <li><b>Dimension Extraction:</b> Combines {@code metadata-extractor} and {@code ImageIO}
 to reliably determine physical image dimensions.</li>
 <li><b>UI Integration:</b> Provides utility methods to load images into JavaFX
 compatible formats.</li>
 </ul>
 */
public class MetadataService {

    private static final Logger logger = LoggerFactory.getLogger(MetadataService.class);

    // ==================================================================================
    // Configuration & State
    // ==================================================================================

    private final ObjectMapper mapper = new ObjectMapper()
            .configure(JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS, true)
            .configure(JsonParser.Feature.ALLOW_COMMENTS, true);

    private final List<MetadataStrategy> jsonStrategies = Arrays.asList(
            new SwarmUIStrategy(),
            new ComfyUIStrategy(),
            new InvokeAIStrategy(),
            new NovelAIStrategy(),
            new CommonStrategy()
    );

    // ==================================================================================
    // Public API
    // ==================================================================================

    /**
     Retrieves the raw metadata string from the image without parsing.

     @param file The image file to inspect.

     @return The raw metadata chunk, or null if none is found.
     */
    public String getRawMetadata(File file) {
        return findBestMetadataChunk(file);
    }

    /**
     Processes an image and returns a map of structured metadata keys and values.

     @param file The image file to parse.

     @return A map containing extracted data (e.g., Prompt, Model, Seed, Software).
     */
    public Map<String, String> getExtractedData(File file) {
        Map<String, String> results = new HashMap<>();

        // 1. Physical Extraction (File specific)
        extractPhysicalDimensions(file, results);

        // 2. Text Chunk Extraction (File specific)
        String rawData = findBestMetadataChunk(file);

        // 3. Logic Parsing (Delegated to helper for testability)
        results.putAll(processRawMetadata(rawData));

        return results;
    }

    /**
     Helper method to parse a raw metadata string into structured key-value pairs.
     <p>
     This method exposes the parsing logic directly, allowing for unit testing
     without requiring physical image files.
     </p>

     @param rawData The raw string found in the image metadata chunks (JSON or Text).

     @return A map of parsed parameters.
     */
    public Map<String, String> processRawMetadata(String rawData) {
        Map<String, String> results = new HashMap<>();

        if (rawData == null || rawData.isEmpty()) {
            results.put("Prompt", "No metadata found in this image.");
            return results;
        }

        results.put("Raw", rawData);
        String trimmed = rawData.trim();

        if (trimmed.startsWith("{") ||
                (trimmed.startsWith("\"") && trimmed.contains("\"prompt\""))) {
            parseJsonMetadata(trimmed, results);
        } else if (rawData.contains("Steps:") &&
                (rawData.contains("Sampler:") || rawData.contains("Schedule type:"))) {
            results.putAll(TextParamsParser.parse(rawData));
            results.put("Software", "A1111 / Forge");
        } else {
            results.put("Prompt", rawData);
            results.put("Software", "Unknown");
        }

        return results;
    }

    /**
     Loads a File into a JavaFX Image. Falls back to URI loading if ImageIO fails.

     @param file The image file to load.

     @return A JavaFX Image object.
     */
    public static javafx.scene.image.Image loadFxImage(File file) {
        try {
            BufferedImage bImg = ImageIO.read(file);
            if (bImg != null) {
                return javafx.embed.swing.SwingFXUtils.toFXImage(bImg, null);
            }
        } catch (Exception e) {
            logger.error("ImageIO failed for {}: {}", file.getName(), e.getMessage());
        }
        return new javafx.scene.image.Image(file.toURI().toString());
    }

    // ==================================================================================
    // Physical Metadata Extraction
    // ==================================================================================

    private void extractPhysicalDimensions(File file, Map<String, String> results) {
        int width = 0;
        int height = 0;

        try {
            Metadata metadata = ImageMetadataReader.readMetadata(file);
            for (Directory directory : metadata.getDirectories()) {
                for (Tag tag : directory.getTags()) {
                    String name = tag.getTagName().toLowerCase();
                    String desc = tag.getDescription();
                    if (desc == null || desc.isEmpty()) continue;
                    if (name.contains("thumbnail") || name.contains("resolution")) continue;

                    String valStr = desc.split(" ")[0];
                    if (!valStr.matches("\\d+")) continue;

                    int val = Integer.parseInt(valStr);
                    if (val <= 0) continue;

                    if (name.contains("width") && val > width) width = val;
                    if (name.contains("height") && val > height) height = val;
                }
            }
        } catch (Exception e) {
            logger.debug("Failed to read metadata using ImageMetadataReader for {}: {}", file.getName(), e.getMessage());
        }

        try (ImageInputStream in = ImageIO.createImageInputStream(file)) {
            Iterator<ImageReader> readers = ImageIO.getImageReaders(in);
            if (readers.hasNext()) {
                ImageReader reader = readers.next();
                try {
                    reader.setInput(in);
                    width = reader.getWidth(0);
                    height = reader.getHeight(0);
                } finally {
                    reader.dispose();
                }
            }
        } catch (IOException e) {
            logger.debug("Failed to read dimensions using ImageIO for {}: {}", file.getName(), e.getMessage());
        }
    }

    // ==================================================================================
    // Parameter Chunk Identification
    // ==================================================================================

    private String findBestMetadataChunk(File file) {
        List<String> candidates = new ArrayList<>();

        try {
            Metadata metadata = ImageMetadataReader.readMetadata(file);
            for (Directory directory : metadata.getDirectories()) {
                for (Tag tag : directory.getTags()) {
                    String desc = tag.getDescription();
                    if (desc == null) continue;

                    String tagName = tag.getTagName().toLowerCase();

                    if (tagName.contains("parameters") ||
                            tagName.contains("user comment") ||
                            desc.contains("Steps:")) {
                        candidates.add(desc);
                    } else if (desc.contains("{")) {
                        int braceIndex = desc.indexOf("{");
                        if (braceIndex != -1) {
                            candidates.add(desc.substring(braceIndex).trim());
                        }
                    }
                }
            }
        } catch (Exception e) {
            logger.debug("Failed to extract metadata chunks for {}: {}", file.getName(), e.getMessage());
            return null;
        }

        String bestChunk = null;
        int bestScore = -1;

        for (String chunk : candidates) {
            int score = scoreChunk(chunk);
            if (score > bestScore) {
                bestScore = score;
                bestChunk = chunk;
            }
        }

        return bestChunk;
    }

    private int scoreChunk(String chunk) {
        if (chunk == null) return 0;
        if (chunk.contains("sui_image_params")) return 100;
        if (chunk.matches("(?s).*\\{\\s*\"\\d+\"\\s*:\\s*\\{.*")) return 90;
        if (chunk.contains("Steps:") && chunk.contains("Sampler:")) return 80;
        if (chunk.contains("\"nodes\"") && chunk.contains("\"links\"")) return 10;
        return 0;
    }

    // ==================================================================================
    // JSON Deep-Parsing Logic
    // ==================================================================================

    private void parseJsonMetadata(String json, Map<String, String> results) {
        try {
            String cleanJson = json;

            // Basic cleanup for trailing JSON garbage often found in PNGs
            int lastBrace = cleanJson.lastIndexOf("}");
            if (lastBrace != -1 && lastBrace < cleanJson.length() - 1) {
                cleanJson = cleanJson.substring(0, lastBrace + 1);
            }

            if (cleanJson.startsWith("\"")) {
                cleanJson = cleanJson
                        .substring(1, cleanJson.length() - 1)
                        .replace("\\\"", "\"");
            }

            JsonNode root = mapper.readTree(cleanJson);

            String software = "Unknown";
            if (root.has("sui_image_params")) software = "SwarmUI";
            else if (root.has("meta") && root.get("meta").has("invokeai_metadata")) software = "InvokeAI";
            else if (root.has("uc")) software = "NovelAI";
            else {
                // Check for ComfyUI API format (wrapped in "prompt" object)
                if (root.has("prompt") && root.get("prompt").isObject()) {
                    JsonNode promptNode = root.get("prompt");
                    Iterator<String> promptKeys = promptNode.fieldNames();
                    if (promptKeys.hasNext()) {
                        String firstPk = promptKeys.next();
                        if (firstPk.matches("\\d+") && promptNode.get(firstPk).has("class_type")) {
                            software = "ComfyUI";
                        }
                    }
                }

                // Fallback to standard ComfyUI workflow (root keys are node IDs)
                if ("Unknown".equals(software)) {
                    Iterator<String> keys = root.fieldNames();
                    if (keys.hasNext()) {
                        String firstKey = keys.next();
                        if (firstKey.matches("\\d+") && root.get(firstKey).has("class_type")) {
                            software = "ComfyUI";
                        } else if (root.has("nodes") && root.has("links")) {
                            software = "ComfyUI (Workflow)";
                        }
                    }
                }
            }

            results.put("Software", software);

            findKeysRecursively(root, results, software);

            if (!results.containsKey("Prompt") || results.get("Prompt").isEmpty()) {
                results.put("Prompt", findLongestText(root));
            }
        } catch (Exception e) {
            logger.debug("JSON parsing error: {}", e.getMessage());
            results.put("Prompt", "Error parsing JSON: " + e.getMessage());
        }
    }

    private void findKeysRecursively(JsonNode node, Map<String, String> results, String software) {
        if (node.isObject()) {
            Iterator<Map.Entry<String, JsonNode>> fields = node.fields();
            while (fields.hasNext()) {
                Map.Entry<String, JsonNode> entry = fields.next();

                for (MetadataStrategy strategy : jsonStrategies) {
                    if (software.contains("ComfyUI") && !(strategy instanceof ComfyUIStrategy)) {
                        continue;
                    }
                    strategy.extract(
                            entry.getKey().toLowerCase(),
                            entry.getValue(),
                            node,
                            results
                    );
                }

                findKeysRecursively(entry.getValue(), results, software);
            }
        } else if (node.isArray()) {
            for (JsonNode child : node) {
                findKeysRecursively(child, results, software);
            }
        }
    }

    private String findLongestText(JsonNode node) {
        final String[] longest = {"No descriptive prompt found"};
        node.findValues("text").forEach(v -> {
            String val = v.asText();
            if (val.length() > longest[0].length() && !val.contains("{")) {
                longest[0] = val;
            }
        });
        return longest[0];
    }
}